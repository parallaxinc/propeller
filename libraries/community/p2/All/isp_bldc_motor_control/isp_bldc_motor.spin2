'' =================================================================================================''''   File....... isp_bldc_motor.spin2''   Purpose.... Object providing control interface for a single BLDC motor''   Authors.... Stephen M Moraco''               -- Copyright (c) 2022 Iron Sheep Productions, LLC''               -- see below for terms of use''   E-mail..... stephen@ironsheep.biz''   Started.... Feb 2022''   Updated.... 14 Mar 2022'''' =================================================================================================CON { Public Interface Constants }    '  ID where the P2 Eval Motor Board is plugged in (Enum)    '    (Names of supported PinGroups)    #0[16], PINS_P0_P15, PINS_P16_P31, PINS_P32_P47    ' return value when user makes bad choice    INVALID_PIN_BASE = -1    ' Names of supported voltages    '  Lipo battery sizes: 2s-7.4v, 3s-11.1v, 4s-14.8v, 5s-18.5v, 6s-22.2v, 7s-25.9v    #0, PWR_Unknown, PWR_6V, PWR_7p4V, PWR_11p1V, PWR_12V, PWR_14p8V, PWR_18p5V, PWR_22p2V, PWR_24V    ' return value when user makes bad choice    INVALID_VOLTAGE = -1    VALUE_NOT_SET = -1    ' Driver Distance-Units Enum: (Millimeters, Centimeters, Inches, Feet, Meters, Kilometers, Miles)    #0, DDU_Unknown, DDU_MM, DDU_CM, DDU_IN, DDU_FT, DDU_M, DDU_KM, DDU_MI    ' Driver Rotation-Units Enum:    #0, DRU_Unknown, DRU_HALL_TICKS, DRU_DEGREES, DRU_ROTATIONS    ' Driver Time-Unit Enum:    #0, DTU_Unknown, DTU_MILLISEC, DTU_SEC    ' Driver Status Enum:    #10, DS_Unknown, DS_MOVING, DS_HOLDING, DS_OFF    ' Driver Control Stop-State Enum:    #0, SM_Unknown, SM_FLOAT, SM_BRAKEOBJ { objects / constants included by this object }    user        :   "isp_bldc_motor_userconfig"     ' driver configuration    distConv    :   "isp_dist_utils"                ' distance conversion utilsCON { test pins for LA measurement }{    ' PIN_8 - PIN_15    TEST_BASE_PIN = 8    TEST_ALL_PINS = TEST_BASE_PIN addpins 7    TEST_PIN_OUTER_LOOP = TEST_BASE_PIN + 0       ' LA grey    TEST_PIN_SENSE_LOOP = TEST_BASE_PIN + 1       ' LA red    TEST_PIN_DRIVER_LOOP = TEST_BASE_PIN + 2            ' LA Yellow    TEST_PIN_DRIVER_TMR = TEST_BASE_PIN + 3             ' LA Green    TEST_PIN_DRIVER_TMR2 = TEST_BASE_PIN + 4             ' LA Blue'}DAT { misc time constants }    ticks125ms  long    0                     ' time constants based on CPU freq    ticks500us  long    0                     '    ticks750us  long    0                     '    ticks800us  long    0                     '    ticks1ms    LONG    0                     '    ticks1us    LONG    0                     'PUB null()'' This is not a top-level objectPUB start(eMotorBasePin, eMotorVoltage) : ok | legalBase'' Specify motor control board connect location for this motor and start the driver        ' setup runtime constants    ticks1ms   := (CLKFREQ / 1_000)    ticks1us   := (CLKFREQ / 1_000_000)    ticks125ms := ticks1ms * 125    ticks500us := (ticks1ms * 500) / 1_000  ' phrased this way for better result    ticks750us := (ticks1ms * 750) / 1_000  ' phrased this way for better result    ticks800us := (ticks1ms * 800) / 1_000  ' phrased this way for better result    ' set up debug variables    useDebug := FALSE    showHDMIDebug := FALSE    ' setup driver parameters based on clock rate    dead_gap    := (ticks1us * 260) / 1_000 ' 260 of these made into "value nS"    pwm_limit   := FRAME - dead_gap         'PWM duty hard limit 1/2 freq of PWM    ' .. and set up rest    offset_fwd  := 20 frac 360              ' 96 frac 360 (Doug's motor)    offset_rev  := 340 frac 360             ' 228 frac 360 (Doug's motor)    duty_min    := 100 << 4 #> dead_gap << 4    duty_max    := pwm_limit << 4 <# pwm_limit << 4    duty_up     := 16    duty_dn     := 4    ctrl_ticks  := ticks500us    stop_mode   := SM_FLOAT                 ' enum: [SM_FLOAT, SM_BRAKE]    e_stop      := FALSE    ' NOTES: 220410 -  at 18.5v 50_000 seems to fault a lot on gravel surface (i'm switching) to 40_000 and PWR_14p8V to see if motors stay operational    ' NOTES: 220410 -  at 14.8V 40_000 seems to fault a lot on gravel surface (i'm switching) to 10_000 and PWR_14p8V to see if motors stay operational (5_000 dog slow)    ' NOTES: 220413 -  at 14.8V 10_000 better on gravel surface  but too slow a ramp to 15_000 and PWR_14p8V to see if motors stay operational    ' 50_000 for 12v & 18_5v    ramp_fast   := 50_000                   ' 50k angle increment: add/sub this every 500 uSec to ramp up to speed, or ramp down to zer    ramp_slo    := 8_000                    ' 8k angle decrement: add/sub this every 500 uSec to ramp up from zero (slower initial ramp so we don't fault)    motorIsReversed := FALSE    ' by default our motor direction is not reversed    ' init status variables    loop_ticks := 0    minDrvTics := 65535    drv_state := DS_Unknown    maxSpeed := 75            ' [1-100] default 75    maxSpeed4dist := 75      ' [1-100] default 75    ' preset HDMI Monitor values    tvMaxMmPerSec_x10 := 0    tvMaxFps_x10 := 0    tvMaxMPH_x10 := 0    tvMaxkPH_x10 := 0    userSelectedVolts := VALUE_NOT_SET    ' ensure we don't drive motor unles we know the users' voltage!    debug("* init values ", udec_long(dead_gap), udec_long(ctrl_ticks), udec_long(duty_min), udec_long(pwm_limit), udec_long(duty_max))    circInMM_x10 := distConv.circInMMforDiaInInchFloat(user.MOTOR_DIA_IN_INCH)    tickInMM_x10 := circInMM_x10 / 90    confgurePowerLimits(user.DRIVE_VOLTAGE)    ' ensure we only use legal values    legalBase := eMotorBasePin    CASE eMotorBasePin        PINS_P0_P15 :        PINS_P16_P31 :        PINS_P32_P47 :        OTHER :            legalBase := INVALID_PIN_BASE    ' if legal base-pin then start cog    if legalBase <> INVALID_PIN_BASE        pinbase := legalBase        ' record base pin number        params_ptr := @offset_fwd   ' point to driver variables        setTargetAccel(0)           ' do NOT move at startup        ok := motorCog := coginit(NEWCOG, @driver, @pinbase) + 1        if motorCog == 0    ' did fail?            debug("!! ERROR filed to start Motor Control task")PUB startSenseCog() : ok'' Start the single motor sense task (tracks position of motor, distance travelled, etc.)    ok := senseCog := cogspin(NEWCOG, taskPostionSense(), @taskStack) + 1    if senseCog == 0    ' did fail?        debug("!! ERROR filed to start Position Sense task")PUB stop()'' Stop cogs and release pins assigned to this motor    if motorCog     ' stop motor drive        cogstop(motorCog - 1)        motorCog := 0    ' Bottom 8 pins are sensed, top 8 are driven, so clear only the top 8    pinclear(pinbase+8 addpins 7)    if senseCog     ' stop motor reads        cogstop(senseCog - 1)        senseCog := 0VAR { * user request values * }    LONG    userSelectedVolts     ' remember the value specified by the user    ' limits based on user voltage    LONG    minFwdIncreAtPwr    LONG    maxFwdIncreAtPwr    LONG    minRevIncreAtPwr    LONG    maxRevIncreAtPwr    ' user max speeds    LONG    maxSpeed            ' [1-100] default 75    LONG    maxSpeed4dist       ' [1-100] default 75    ' stop point in time based on passing mSec or tick counts    LONG    motorStopMSecs      ' stop motor when we've passed this time in milliseconds    LONG    motorStopHallTicks  ' stop motor when we've passed this tick count    LONG    motorPower          ' remember last power requested    LONG    motorIsReversed     ' T/F where T means we need to flip direction: FWD <-> REV    ' debug control variables    LONG    useDebug    LONG    showHDMIDebugPUB setAcceleration(rate)'' NOT WORKING: Limit Acceleration to {rate} where {rate} is [??? - ???] mm/s squared (default is ??? mm/s squared)PUB setMaxSpeed(speed) | limitSpeed'' Limit top-speed to {speed} where {speed} is [1 to 100]  (default is 75)    limitSpeed :=  1 #> speed <# 100    if limitSpeed <> speed        debug("! WARNING: driveAtPower() speed out of range (corrected):", udec_long(speed), " - must be [1 to 100]")    debug("setMaxSpeed() ", udec_long(limitSpeed))    maxSpeed := limitSpeed      ' remember user valuePUB setMaxSpeedForDistance(speed) | limitSpeed4dist'' Limit top-speed of driveDistance() operations to {speed} where {speed} is [1 to 100]  (default is 75)    limitSpeed4dist :=  1 #> speed <# 100    if limitSpeed4dist <> speed        debug("! WARNING: driveAtPower() speed out of range (corrected):", udec_long(speed), " - must be [1 to 100]")    debug("setMaxSpeedForDistance() ", udec_long(limitSpeed4dist))    maxSpeed4dist := limitSpeed4dist      ' remember user valuePUB calibrate()'' NOT WORKING: (we may need this?)PUB holdAtStop(bEnable)'' Informs the motor control cog to actively hold position (bEnable=true) or coast (bEnable=false) at end of motion    stop_mode := (bEnable) ? SM_BRAKE : SM_FLOATPUB resetTracking()'' Resets the position tracking values returned by getDistance() and getRotations()    posTrkHallTicks := 0    ' reset all of our trackers (they are incremented in sensor loop)CON { --- Subsystem Control --- }PUB driveForDistance(distance, distanceUnits)'' Control the forward direction of this motor using the {distance} and {distanceUnits} inputs.'' Turn the motor on then turn it off again after it reaches the specified {distance} in {distanceUnits} [DDU_IN, DDU_CM, DDU_FT or DDU_M].'' AFFECTED BY:  setAcceleration(), setMaxSpeedForDistance(), holdAtStop()    stopAfterDistance(distance, distanceUnits)    driveAtPower(maxSpeed4dist)PUB driveAtPower(power) | limitPwr, motorIncre, correctedPower'' Control the speed and direction of this motor using the {power, [(-100) to 100]} input.'' Turns the motor on at {power}.'' AFFECTED BY:  setAcceleration(), setMaxSpeed(), holdAtStop()    limitPwr :=  -100 #> power <# 100    if limitPwr <> power        debug("! WARNING: driveAtPower() power out of range (corrected):", udec_long(power), " - must be [-100 to +100]")    debug("driveAtPower() ", sdec_long(limitPwr), udec_long(ramp_fast), udec_long(ramp_slo))    if limitPwr < 0        ' handle reverse speed        if limitPwr < 0 - maxSpeed            limitPwr := 0 - maxSpeed    ' cap at max speed in reverse    else        ' handle forward speed        if limitPwr > maxSpeed            limitPwr := maxSpeed    ' cap at max speed forward    motorPower := limitPwr    correctedPower := (motorIsReversed) ? 0 - limitPwr : limitPwr    motorIncre := incrementForPower(correctedPower)    setTargetAccel(motorIncre)    debug("driveAtPower() EXIT ")PUB stopAfterRotation(nRotationCount, eRotationUnits)'' Stops the motor after it reaches {rotationCount} of {rotationUnits} [DRU_HALL_TICKS, DRU_DEGREES, or DRU_ROTATIONS].'' USE WITH:  driveAtPower()'' Will ABORT if {rotationCount} < 1    if nRotationCount < 1        debug("! ERROR: invalid RotationCount Value:", udec_long(nRotationCount), " - must be > 0!")        ' FIXME: UNDONE should be more than ticks needed for spin-up/down ramps!!!        abort    ' FIXME: UNDONE convert this to use runtime values based on user specified wheel size ( we assume wheel is 90 tics! )    ' FIXME: UNDONE remove # ticks for spin-up/down ramps!!!    ' convert rotation info to ticks (will stop at ticks limit)    motorStopHallTicks := 0    case eRotationUnits        DRU_HALL_TICKS:            motorStopHallTicks := nRotationCount        DRU_DEGREES:            ' ticks = degrees / 4            motorStopHallTicks := nRotationCount / 4        DRU_ROTATIONS:            ' ticks = rotations * 90            motorStopHallTicks := nRotationCount * 90        other:            debug("! ERROR: invalid rotationUnits Value:", udec_long(eRotationUnits))            abortPUB stopAfterDistance(nDistance, eDistanceUnits) | fValue'' Stops the motor after either it reaches {distance} specified in {distanceUnits} [DDU_MM, DDU_CM, DDU_IN, DDU_FT, DDU_M].'' USE WITH:  driveAtPower()'' Will ABORT if {distance} < 1    if nDistance < 1        debug("! ERROR: invalid Distance Value:", udec_long(nDistance), " - must be > 0!")        ' FIXME: UNDONE should be more than ticks needed for spin-up/down ramps!!!        abort    ' FIXME: UNDONE convert this to use runtime values based on user specified wheel size ( we assume wheel is 90 tics! )    ' FIXME: UNDONE remove time needed for spin-up/down ramps!!!    ' convert distance to ticks (will stop at ticks limit)    case eDistanceUnits        DDU_MM:            motorStopHallTicks := (nDistance * 10) / tickInMM_x10        DDU_CM:            motorStopHallTicks := (nDistance * 10 * 10) / tickInMM_x10        DDU_IN:            fValue := distConv.fIn2mm(nDistance)            motorStopHallTicks := trunc(fValue *. 10.0) / tickInMM_x10        DDU_FT:            fValue := distConv.fIn2mm(nDistance * 12)            motorStopHallTicks := trunc(fValue *. 10.0) / tickInMM_x10        DDU_M:            motorStopHallTicks := (nDistance * 100 * 10) / tickInMM_x10        other:            debug("! ERROR: invalid distanceUnits Stop Value:", udec_long(eDistanceUnits))            abortPUB stopAfterTime(nTime, eTimeUnits) | timeNow'' Stops the motor, after {time} specified in {timeUnits} [DTU_MILLISEC or DTU_SEC] has elapsed.'' USE WITH:  driveAtPower()'' Will ABORT if {time} < 1    if nTime < 1        debug("! ERROR: invalid nTime Value:", udec_long(nTime), " - must be > 0!")        ' FIXME: UNDONE should be more than time needed for spin-up/down ramps!!!        abort    case eTimeUnits        DTU_MILLISEC:        DTU_SEC:        other:            debug("! ERROR: invalid timeUnits Value:", udec_long(eTimeUnits))            abort    ' FIXME: UNDONE remove time needed for spin-up/down ramps!!!    if eTimeUnits == DTU_SEC        timeNow := getms()        motorStopMSecs := timeNow + (nTime * 1_000)    else        timeNow := getms()        motorStopMSecs := timeNow + nTime    if motorStopMSecs > 0        debug("* stop motor at ", udec_long(motorStopMSecs), ", now: ", udec_long(timeNow))PUB stopMotor()'' Stops the motor, killing any motion that was still in progress''  AFFECTED BY:holdAtStop()    setTargetAccel(0)PUB emergencyCutoff()'' EMERGENCY-Stop - Immediately stop motor, killing any motion that was still in progress    e_stop := TRUE    setTargetAccel(0)    debug("-- EMERGENCY STOP --")PUB clearEmergency()'' clear EMERGENCY-Stop - remove the need to stop!    e_stop := FALSE    debug("-- EMERGENCY -- CLEARED --")PUB forwardIsReverse()'' call when we have two motors and one of them needs to be reversed    motorIsReversed := TRUECON { --- Subsystem Status --- }PUB getDistance(eDistanceUnits) : nDistanceInUnits | fMMpTick, fValue'' Returns the distance in {distanceUnits} [DDU_MM, DDU_CM, DDU_IN, DDU_FT, DDU_M, DDU_KM, DDU_MI] travelled by this motor since last reset    fMMpTick := float(circInMM_x10) /. 90.0 /. 10.0    case eDistanceUnits        DDU_MM:            nDistanceInUnits := trunc(float(posTrkHallTicks) *. fMMpTick)        DDU_CM:            nDistanceInUnits := trunc(float(posTrkHallTicks) *. fMMpTick /. 10.0)        DDU_IN:            fValue := distConv.fMm2inFloat(float(posTrkHallTicks) *. fMMpTick)            nDistanceInUnits := trunc(fValue +. 0.5)    ' rounded        DDU_FT:            fValue := distConv.fMm2inFloat(float(posTrkHallTicks) *. fMMpTick)            nDistanceInUnits := trunc(fValue /. 12.0 +. 0.5)    ' in FT, rounded        DDU_M:            fValue := float(posTrkHallTicks) *. fMMpTick            nDistanceInUnits := trunc(fValue /. 1000.0)    ' in M        DDU_MI:            fValue := distConv.fMm2inFloat(float(posTrkHallTicks) *. fMMpTick)            nDistanceInUnits := trunc(fValue /. 5280.0 /. 12.0)    ' in MI        DDU_KM:            fValue := float(posTrkHallTicks) *. fMMpTick            nDistanceInUnits := trunc(fValue /. 1000.0 /. 1000.0)    ' in kM        other:            debug("! ERROR: invalid distanceUnits Value:", udec_long(eDistanceUnits))            abortPUB getRotationCount(eRotationUnits) : rotationCount'' Returns accumulated {rotationCount} in {rotationUnits} [DRU_DEGREES, DRU_ROTATIONS, or DRU_HALL_TICKS], since last reset, for this motor.    rotationCount := 0    case eRotationUnits        DRU_HALL_TICKS:            rotationCount := motorStopHallTicks        DRU_DEGREES:            ' degrees = ticks * 4            rotationCount := motorStopHallTicks * 4        DRU_ROTATIONS:            ' rotations = ticks / 90            rotationCount := motorStopHallTicks / 90        other:            debug("! ERROR: invalid rotationUnits Value:", udec_long(eRotationUnits))            abortPUB getPower() : nPower'' Returns the last specified power value [-100 thru +100] for motor (will be zero if the motor is stopped).    nPower := motorPowerPUB getCurrent() : nAmps, nWatts'' Returns the latest current sense values    nAmps := sense_i    nWatts := 0PUB getMaxSpeed() : nSpeed'' Returns the last specified {maxSpeed}    nSpeed := maxSpeed  ' return last specified user valuePUB getMaxSpeedForDistance() : nSpeed4dist'' Returns the last specified {maxSpeedForDistance}    nSpeed4dist := maxSpeed4dist  ' return last specified user valuePUB getStatus() : eStatus'' Returns status of motor drive state for this motor: enumerated constant: DS_Unknown, DS_MOVING, DS_HOLDING, or DS_OFF    if isStopped()        if stop_mode == SM_BRAKE            eStatus := DS_HOLDING        elseif stop_mode == SM_FLOAT            eStatus := DS_OFF    elseif isReady()        eStatus := DS_MOVING    else        eStatus := DS_UnknownPUB getDriveState() : eDrvState'' Return Enum [DCS_*] value representing state of driver    eDrvState := drv_statePUB getRawHallTicks() : nPos'' Return the raw driver-maintained tick count    nPos := posPUB isReady() : bState'' Return T/F where T means the motor cog is running    bState := (drv_state <> DCS_Unknown) ? true : falsePUB isStopped() : bState'' Return T/F where T means the motor is stopped    bState := (drv_state == DCS_STOPPED) ? true : falsePUB isStarting() : bState'' Return T/F where T means the motor is spinning up    bState := (drv_state == DCS_SPIN_UP) ? true : falsePUB isEmergency() : bState'' Return T/F where T means the motor is emergency-stopped    bState := (drv_state == DCS_ESTOP) ? true : falseCON { --- PRIVATE Utility Methods --- }PUB validBasePinForChoice(userBasePin) : legalBasePin'' VALIDATE users' base-pin choice returns legalBasePin or INVALID_PIN_BASE    legalBasePin := userBasePin    CASE userBasePin        PINS_P0_P15 :        PINS_P16_P31 :        PINS_P32_P47 :        OTHER :            legalBasePin := INVALID_PIN_BASEPUB validVoltageForChoice(userVoltage) : legalVoltage'' VALIDATE users' voltage choice returns legalVoltage or INVALID_VOLTAGE    legalVoltage := userVoltage    CASE userVoltage        PWR_6V:        PWR_7p4V:        PWR_11p1V:        PWR_12V:        PWR_14p8V:        PWR_18p5V:        PWR_22p2V:        PWR_24V:        OTHER:            legalVoltage := INVALID_VOLTAGE    debug("*VAL* ", sdec_long(legalVoltage))PRI map(inValue, inMin, inMax, outMin, outMax) : nResult | slope' Maps inValue in range inMin..inMax to new value in range outMin..outMax    nResult := 0    if inValue <> 0        if (inValue > 0)            ' treat positive values out-of-bounds            if (inValue <= inMin)                nResult := outMin            elseif (inValue >= inMax)                nResult :=  outMax        elseif (inValue < 0)            ' treat negative values out-of-bounds            if (inValue >= inMin)                nResult := outMin            elseif (inValue <= inMax)                nResult :=  outMax        ' NOT  out-of-bounds, so scale the inValue        if nResult == 0            slope := (outMax - outMin) / (inMax - inMin)            nResult := outMin + slope * (inValue - inMin)    'debug("- map() ", sdec_long(inValue - inMin), sdec_long(inMin) , sdec_long(inMax), sdec_long(inMax - inMin))    'debug("-       ", sdec_long(slope), sdec_long(outMin) , sdec_long(outMax), sdec_long(outMax - outMin))    debug("- map() ", sdec_long(inValue) , " --> ", sdec_long(nResult))PRI incrementForPower(nUserPower) : nMotorIncre' translate -100 to +100 value to Incre value needed by motor    if userSelectedVolts == VALUE_NOT_SET        abort    if nUserPower < 0        ' map REV request        nMotorIncre := map(nUserPower, -1, -100, minRevIncreAtPwr, maxRevIncreAtPwr)    elseif nUserPower > 0        ' map FWD request        nMotorIncre := map(nUserPower, +1, +100, minFwdIncreAtPwr, maxFwdIncreAtPwr)    else        ' this is a STOP request        nMotorIncre := 0    ' stop!PRI confgurePowerLimits(userVoltage) | selectedPower' set up our motor drive limits based upon the user configured Voltage selection    selectedPower := validVoltageForChoice(userVoltage)    debug("* ENTRY CFG ", sdec_long(selectedPower))    if selectedPower == INVALID_VOLTAGE        abort    userSelectedVolts := VALUE_NOT_SET  ' preset    minFwdIncreAtPwr := VALUE_NOT_SET    maxFwdIncreAtPwr := VALUE_NOT_SET    minRevIncreAtPwr := VALUE_NOT_SET    maxRevIncreAtPwr := VALUE_NOT_SET    CASE selectedPower        PWR_6V:        PWR_7p4V:        PWR_11p1V:            maxFwdIncreAtPwr := 90_000_000      ' anything above yields RPM 165.3, cts/Sec 248 (until fault at 170.6 256)            maxRevIncreAtPwr := -90_000_000     ' anything above yields RPM 165.3, cts/Sec 248 (until fault at 170.6 256)        PWR_12V:            maxFwdIncreAtPwr := 97_000_000      ' anything above yields RPM 181.3, cts/Sec 272 (until fault at 186.6 280)            maxRevIncreAtPwr := -97_000_000     ' anything above yields RPM 181.3, cts/Sec 272 (until fault at 186.6 280)        PWR_14p8V:            maxFwdIncreAtPwr := 120_000_000     ' anything above yields RPM 224.0, cts/Sec 336 (until fault at 229.8 344)            maxRevIncreAtPwr := -120_000_000    ' anything above yields RPM 224.0, cts/Sec 336 (until fault at 229.8 344)        PWR_18p5V:            maxFwdIncreAtPwr := 147_000_000     ' anything above yields RPM 272.0, cts/Sec 408 (until fault at 277.3 416)            maxRevIncreAtPwr := -147_000_000    ' anything above yields RPM 272.0, cts/Sec 408 (until fault at 277.3 416)        PWR_22p2V:            maxFwdIncreAtPwr := 172_000_000     ' anything above yields RPM 320.0, cts/Sec 480 (until fault at 325.3 480)            maxRevIncreAtPwr := -172_000_000    ' anything above yields RPM 320.0, cts/Sec 480 (until fault at 325.3 480)        PWR_24V:       other:            debug("*???* Unknown: ", sdec_long(selectedPower))            abort   ' SHOULD NEVER get here!    if maxFwdIncreAtPwr <> VALUE_NOT_SET        userSelectedVolts := selectedPower        minFwdIncreAtPwr := 5_000_000           ' anything below yields RPM 5.3, cts/Sec 8        minRevIncreAtPwr := 0 - minFwdIncreAtPwr    debug("* EXIT 2 CFG ", sdec_long(userSelectedVolts))PRI setTargetAccel(nTgtIncr)    targetIncre := nTgtIncr    debug("-MOT- ", sdec_long(targetIncre))    tvTargetIncreInM := nTgtIncr / 10_000CON { --- HDMI Debug Support --- }CON { Constants for HDMI Debug }    DBG_GROUPS_CT = 3    DBG_MAX_VARS_IN_GROUP = 7VAR { * Data Structure for HDMI Debug * }    LONG    pTitlesAr[DBG_GROUPS_CT + 1]    ' first value is max vars    LONG    pVarCtAr[DBG_GROUPS_CT]    LONG    pNamesAr[DBG_GROUPS_CT * DBG_MAX_VARS_IN_GROUP]    LONG    pValsAr[DBG_GROUPS_CT*DBG_MAX_VARS_IN_GROUP]DAT { Literals for HDMI Debug }' motor drive data    nameTitle1  BYTE    "Motor Drive",0    name10      BYTE    "hall",0    name11      BYTE    "pos",0    name12      BYTE    "duty",0    name13      BYTE    "err",0    name14      BYTE    "loopTicks",0    name15      BYTE    "state",0    name16      BYTE    "FAULT",0    nextAddr1    dataLen1     LONG    @nextAddr1 - @nameTitle1' motor sense data    nameTitle2  BYTE    "Motor Sense",0    name20      BYTE    "RPM 10ths",0    name21      BYTE    "RPM",0    name22      BYTE    "cnts/sec",0    name23      BYTE    "delta",0    nextAddr2    dataLen2     LONG    @nextAddr2 - @nameTitle2' motor rate  data    nameTitle3  BYTE    "Motor Rate(.1)",0    name30      BYTE    "RPM",0    name31      BYTE    "cnts/sec",0    name32      BYTE    "f/s",0    name33      BYTE    "MPH",0    name34      BYTE    "kM/H",0    name35      BYTE    "mm/s",0    name36      BYTE    "Angl/10k",0    nextAddr3    dataLen3     LONG    @nextAddr3 - @nameTitle3PRI loadDisplayList() | nGrpOffset, nValsGrpOffset, nVarsInGroup' do internal one-time setup of driver debug data    nGrpOffset := 0    nVarsInGroup := 7    LONG[@pTitlesAr][nGrpOffset] := @nameTitle1    LONG[@pVarCtAr][nGrpOffset] := nVarsInGroup    ' populate the empty name/value ptr tables    nValsGrpOffset := nGrpOffset * DBG_MAX_VARS_IN_GROUP    LONG[@pNamesAr][nValsGrpOffset + 0] := @name10    LONG[@pNamesAr][nValsGrpOffset + 1] := @name11    LONG[@pNamesAr][nValsGrpOffset + 2] := @name12    LONG[@pNamesAr][nValsGrpOffset + 3] := @name13    LONG[@pNamesAr][nValsGrpOffset + 4] := @name14    LONG[@pNamesAr][nValsGrpOffset + 5] := @name15    LONG[@pNamesAr][nValsGrpOffset + 6] := @name16    LONG[@pValsAr][nValsGrpOffset + 0] := @hall    LONG[@pValsAr][nValsGrpOffset + 1] := @pos    LONG[@pValsAr][nValsGrpOffset + 2] := @duty    LONG[@pValsAr][nValsGrpOffset + 3] := @err    LONG[@pValsAr][nValsGrpOffset + 4] := @loop_ticks    LONG[@pValsAr][nValsGrpOffset + 5] := @drv_state    LONG[@pValsAr][nValsGrpOffset + 6] := @fault    nGrpOffset := 1    nVarsInGroup := 4    LONG[@pTitlesAr][nGrpOffset] := @nameTitle2    LONG[@pVarCtAr][nGrpOffset] := nVarsInGroup     ' populate the empty name/value ptr tables    nValsGrpOffset := nGrpOffset * DBG_MAX_VARS_IN_GROUP ' mult by vars in prior group    LONG[@pNamesAr][nValsGrpOffset + 0] := @name20    LONG[@pNamesAr][nValsGrpOffset + 1] := @name21    LONG[@pNamesAr][nValsGrpOffset + 2] := @name22    LONG[@pNamesAr][nValsGrpOffset + 3] := @name23    LONG[@pValsAr][nValsGrpOffset + 0] := @tvRpm_x10    LONG[@pValsAr][nValsGrpOffset + 1] := @rpm    LONG[@pValsAr][nValsGrpOffset + 2] := @cntsInSec    LONG[@pValsAr][nValsGrpOffset + 3] := @deltaTicks    nGrpOffset := 2    nVarsInGroup := 7    LONG[@pTitlesAr][nGrpOffset] := @nameTitle3    LONG[@pVarCtAr][nGrpOffset] := nVarsInGroup     ' populate the empty name/value ptr tables    nValsGrpOffset := nGrpOffset * DBG_MAX_VARS_IN_GROUP ' mult by vars in prior group    LONG[@pNamesAr][nValsGrpOffset + 0] := @name30    LONG[@pNamesAr][nValsGrpOffset + 1] := @name31    LONG[@pNamesAr][nValsGrpOffset + 2] := @name32    LONG[@pNamesAr][nValsGrpOffset + 3] := @name33    LONG[@pNamesAr][nValsGrpOffset + 4] := @name34    LONG[@pNamesAr][nValsGrpOffset + 5] := @name35    LONG[@pNamesAr][nValsGrpOffset + 6] := @name36    LONG[@pValsAr][nValsGrpOffset + 0] := @tvMaxRpmIn10ths    LONG[@pValsAr][nValsGrpOffset + 1] := @tvMaxCntsInSec    LONG[@pValsAr][nValsGrpOffset + 2] := @tvMaxFps_x10    LONG[@pValsAr][nValsGrpOffset + 3] := @tvMaxMPH_x10    LONG[@pValsAr][nValsGrpOffset + 4] := @tvMaxkPH_x10    LONG[@pValsAr][nValsGrpOffset + 5] := @tvMaxMmPerSec_x10    LONG[@pValsAr][nValsGrpOffset + 6] := @tvTargetIncreInM    ' tell our table size to reader    nGrpOffset := 3    LONG[@pTitlesAr][nGrpOffset] := DBG_MAX_VARS_IN_GROUPPUB getDebugData() : nGroups, pGroupTitles, pGroupNames, pGroupVarCts, pGroupVars | tmpAbsPtr'' Return pointers to HDMI-debug data structures for this motor-object instance    loadDisplayList()    nGroups := DBG_GROUPS_CT    pGroupTitles := @pTitlesAr         ' pStr = long[pTitlesAr][grpIdx]    pGroupVarCts := @pVarCtAr          ' nNbrGrpVars = long[pVarCtAr][grpIdx]    pGroupNames := @pNamesAr           ' pGrpNameAr = long[pNamesAr][grpIdx], pVarName = long[pNameAr][varIdx]  where varIdx is from 0 to nNbrGrpVars - 1    pGroupVars := @pValsAr             ' pGrpLongVar = long[pValsAr][grpIdx][varIdx]  where varIdx is from 0 to nNbrGrpVars - 1    if showHDMIDebug        debug("* -------------")        debug("* MOTR DAT values: ", uhex_long(@hall), uhex_long_array(@hall, 4))        debug("* MOTR VAR values: ", uhex_long(@tvRpm_x10), uhex_long_array(@tvRpm_x10, 4))        debug("* NAMEs SOURCE1: ", uhex_long(@nameTitle1), uhex_byte_array(@nameTitle1, dataLen1))        debug("* NAMEs SOURCE2: ", uhex_long(@nameTitle2), uhex_byte_array(@nameTitle2, dataLen2))        debug("* NAMEs SOURCE3: ", uhex_long(@nameTitle3), uhex_byte_array(@nameTitle3, dataLen3))        debug("* -------------")        debug("* MOTR DL title: ", uhex_long(@pTitlesAr), uhex_long_array(@pTitlesAr, DBG_GROUPS_CT + 1))        debug("* MOTR DL VarCt: ", uhex_long(@pVarCtAr), uhex_long_array(@pVarCtAr, DBG_GROUPS_CT))        debug("* MOTR DL Names: ", uhex_long(@pNamesAr), uhex_long_array(@pNamesAr, DBG_GROUPS_CT * DBG_MAX_VARS_IN_GROUP))        debug("* MOTR DL Values: ", uhex_long(@pValsAr), uhex_long_array(@pValsAr, DBG_GROUPS_CT * DBG_MAX_VARS_IN_GROUP))        debug("* -------------")        debug("* MOTR PARM values: ", uhex_long(@nGroups), uhex_long_array(@nGroups, 5))        debug("* -------------")        debug("* MOTR Sent: ", udec(nGroups), uhex_long(pGroupTitles), uhex_long(pGroupNames), uhex_long(pGroupVarCts), uhex_long(pGroupVars))        debug("* =============")CON { -- TASK position tracking -- }  STACK_SIZE_LONGS = 48  WINDOW_SIZE = 5VAR { * sense buffer and stack arrays * }    LONG    countsWindow[WINDOW_SIZE]    LONG    taskStack[STACK_SIZE_LONGS]PRI taskPostionSense() | senseStartTicks, posThis8th, fValue, fFps, timeNow, eStopCtr' TASK: every 1/8 Sec (8Hz) read motor pos and calculate RPM and countOf90ths/Sec    'longfill(@countsWindow, 0, WINDOW_SIZE) ' zero our window accum    'tvMaxRpmIn10ths := tvMaxCntsInSec := tvMaxMmPerSec_x10 := 0    'tvMaxFps_x10 := tvMaxMPH_x10 := tvMaxkPH_x10 := 0    eStopCtr := tvMaxRpmIn10ths := tvMaxCntsInSec := tvMaxMmPerSec_x10 := 0    repeat        ' if just starting up (or MOTOR FAULT), reset our tracker        if drv_state == DCS_FAULTED or senseStartTicks == 0            longfill(@countsWindow, 0, WINDOW_SIZE) ' zero our window accum            tvMaxFps_x10 := tvMaxMPH_x10 := tvMaxkPH_x10 := 0            winEntryCt := windowSum := winIndex := 0            posTrkHallTicks := 0        senseStartTicks := getct()        'pintoggle(TEST_PIN_SENSE_LOOP)        'pintoggle(TEST_PIN_SENSE_LOOP)        newCntsInSec := distanceIn90ths(pos)            ' Read the next sensor value        windowSum -= LONG[@countsWindow][winIndex]          ' Remove the oldest entry from the sum        long [@countsWindow][winIndex] := newCntsInSec      ' place the newest reading into the window        windowSum += newCntsInSec                           ' Add the newest reading to the sum        winIndex := (winIndex + 1) +// WINDOW_SIZE          ' Increment the index, and wrap to 0 if it exceeds the window size        if winEntryCt < WINDOW_SIZE                         ' incr number of samples in sum until is window size            winEntryCt++        cntsInSec := (windowSum / winEntryCt) * 8                 ' moving average, scaled        tvRpm_x10 := (cntsInSec * 60) / 9        rpm := tvRpm_x10 / 10        rpmTenths := tvRpm_x10 +// 10        tvMaxRpmIn10ths := MAX(tvRpm_x10, tvMaxRpmIn10ths)        tvMaxCntsInSec := MAX(cntsInSec, tvMaxCntsInSec)        posThis8th := windowSum / winEntryCt        posTrkHallTicks += posThis8th        ' pos is in hall-steps of 4Degr each.        ' circumference of wheel is in mm x10        '   degrees of rotation is cntsInSec * 4        '   number of rotations is degrees / 360        '   dist in mm is (circInMM_x10 * rotations) / 10        mmPerSec_x10 := (((cntsInSec * 4) * circInMM_x10) / 360)        ftPerSec_x10 := distConv.mmps2fps(mmPerSec_x10 * 10)        kmh_x10 := distConv.mmps2kmh(mmPerSec_x10 * 10)        mph_x10 := distConv.fps2mph(ftPerSec_x10)        tvMaxMmPerSec_x10 := MAX(mmPerSec_x10, tvMaxMmPerSec_x10)        tvMaxFps_x10 := MAX(ftPerSec_x10, tvMaxFps_x10)        tvMaxMPH_x10 := MAX(mph_x10, tvMaxMPH_x10)        tvMaxkPH_x10 := MAX(kmh_x10, tvMaxkPH_x10)        ' if user set time/distance to stop then stop if we are past the time or distance        if motorStopMSecs > 0            timeNow := getms()            if timeNow > motorStopMSecs                setTargetAccel(0)                motorStopMSecs := 0 ' and clear user request        elseif motorStopHallTicks > 0            if posTrkHallTicks > motorStopHallTicks                setTargetAccel(0)                motorStopHallTicks := 0 ' and clear user request        deltaTicks := getct() - senseStartTicks        ' iff driver reports e-stop then clear the emergency stop request        '  user will request it again if needed        ' NOTE: we leave e_stop set for at least 1/8 second before clearing!        if drv_state == DCS_ESTOP && eStopCtr == 0            eStopCtr++        elseif drv_state == DCS_ESTOP && eStopCtr > 0            e_stop := FALSE            eStopCtr := 0        ' code uses about 1_880 ticks. This is little over 9 uS  @200MHz clock        '   wait remainder of 125 mSec before next sample        waitct(senseStartTicks + ticks125ms)    ' wait to create "sense" time-basePRI MAX(a,b) : nMax' return max of a or b    nMax := (a > b) ? a : bPRI distanceIn90ths(newPos) : n90ths    if newPos == priorPos        n90ths := 0    elseif newPos < 0        ' handle pos negative case        if priorPos < 0            '  -7 -> -9 = abs(-9) - abs(-7) = abs(2) = 2            '  -11 -> -9 = abs(-9) - abs(-11) = abs(-2) = 2            n90ths := abs(abs(newPos) - abs(priorPos))        else            '  9 -> -9 = 18 = abs(9) + abs(-9) = 18            n90ths := abs(newPos) + abs(priorPos)    else        ' handle pos positive case        if priorPos < 0            ' -9 -> 6 = 6 + abs(-9) = 15            ' -3 -> 6 = 6 + abs(-3) = 9            n90ths := newPos + abs(priorPos)        else            ' 9 -> 6 = 6 - 9 = abs(-3) = 3            ' 9 -> 12 = 12 - 9 = abs(3) = 3            n90ths := abs(newPos - priorPos)    priorPos := newPosCON { --- The Motor driver --- }CON { driver interface Constants}    '  DCS_STOPPED          - motor is stopped    '  DCS_SPIN_UP          - motor is ramping up to speed, then will be at AT_SPEED    '  DCS_AT_SPEED         - motor is holding at speed    '  DCS_SPIN_DN          - motor is stopping, then will be at STOPPED    '  DCS_SLOWING_DN       - motor is slowing down (just a speed change), then will be at AT_SPEED    '  DCS_SLOW_TO_CHG      - motor is slowing down to change direction, then will be SPEEDING_UP    '    #0, DCS_Unknown, DCS_STOPPED, DCS_SPIN_UP, DCS_AT_SPEED, DCS_SPIN_DN, DCS_SLOWING_DN, DCS_SLOW_TO_CHG, DCS_FAULTED, DCS_ESTOPCON { driver internal Constants}    FRAME    = 1024 * 6 / 2       '6 ADC samples make 1 PWM frame, divide by two for triangle PWM'    OFFSET   = 40                ' enforced dead time in clock cycles (at 200_000_000 -> 200 nSec)'    OFFSET   = 80                ' enforced dead time in clock cycles (at 200_000_000 -> 400 nSec)'    OFFSET   = 108                ' enforced dead time in clock cycles (at 270_000_000 -> 400 nSec)'    PWMLIM   = FRAME - OFFSET     'PWM duty hard limit 1/2 freq of PWMVAR { * Data Structure for PASM Driver * }  ' remember these are zeroed at run time    LONG    motorCog                            ' record ID of cog we start (0 = not started)    LONG    senseCog                            ' record ID of cog we start (0 = not started)    LONG    maxDrvTics                          ' accumulators for study of driver    LONG    minDrvTics    LONG    pinbase                             ' 1 long                must set initially    LONG    params_ptr                          ' 1 long                must set initially    ' / ----------------------------    LONG    targetIncre                         ' 1 long                must set to cause motion    LONG    emerStop                            ' 1 long                T/F where T means float all pins    ' 14 longs come from driver, the 15th, "fault" also from driver but only when happens    LONG    drive_u, drive_v, drive_w           ' 3 sequential longs    returns data continually    LONG    sense_u, sense_v, sense_w, sense_i  ' 4 sequential longs    returns data continually    LONG    hall, pos, duty, err                ' 4 sequential longs    returns data continually    LONG    loop_ticks                          ' 1 sequential long     returns control loop duration in ticks continually    LONG    loop_ctcks                          ' 1 sequential long     returns drive loop duration in ticks continually    LONG    drv_state                           ' enum [DCS_STOPPED, DCS_SPIN_UP, DCS_AT_SPEED, DCS_SPIN_DN]    ' \ ----------------------------    LONG    fault                               ' 1 sequential long     written to 1 on fault (pins are floated when this happens)VAR { * Data for Motor Position Tracking * }    LONG    winIndex    LONG    winEntryCt    LONG    newCntsInSec    LONG    windowSum    '  ----- HDMI monitored! ----    LONG    tvRpm_x10    LONG    rpm    LONG    cntsInSec    LONG    deltaTicks    LONG    tvMaxRpmIn10ths    LONG    tvMaxFps_x10    LONG    tvMaxMPH_x10    LONG    tvMaxkPH_x10    LONG    tvMaxMmPerSec_x10    LONG    tvMaxCntsInSec    LONG    tvTargetIncreInM    '  --------------------------    LONG    priorPos    LONG    rpmTenths    LONG    mmPerSec_x10    LONG    ftPerSec_x10    LONG    kmh_x10    LONG    mph_x10    '  --------------------------    LONG    posTrkHallTicks    LONG    circInMM_x10    LONG    tickInMM_x10VAR  {  Motor Parameters  }' TABLE of  13 parameters the pasm2 driver reads every cycle    LONG    offset_fwd      ' 96 frac 360 (Doug's motor)    LONG    offset_rev      ' 228 frac 360 (Doug's motor)    LONG    duty_min        ' was 100 << 4 #> OFFSET << 4 but now runtime loaded    LONG    duty_max        ' was PWMLIM << 4 <# PWMLIM << 4 but now runtime loaded    LONG    duty_up    LONG    duty_dn    LONG    dead_gap        ' delay between driving h/l side of driver (never drive both at once)    LONG    pwm_limit       ' max freq of our pwm    LONG    ctrl_ticks      ' # clock ticks needed to create 2 kHz motor control loop    LONG    stop_mode       ' control / user setting, enum: [SM_FLOAT, SM_BRAKE]    LONG    e_stop          ' T/F where T means stop all motor function    LONG    ramp_fast       ' 12_500-18.5V 25k angle increment: add this every 500 uSec to ramp up to speed    LONG    ramp_slo        ' subtract this every 500 uSec to ramp down to slower speedDAT  {  Motor DRIVER  }'' PASM Driver Program'                orgdriver          rdlong  x, ptra++                   ' get base pin                rdlong  params_ptr_, ptra++         ' get parameters pointer                add     ptra, #1*4                  ' point to return data, angle is at long index [-1]                mov     drv_state_, #DCS_STOPPED    ' motor is currently stopped                or      all_pins, x                 ' finish the all-pins variable                add     drive_pins, x               ' finish the drive-pins variable                'drvl    drvrLoopPnFld               ' preset test pins to low                'drvl    drvrTmrPnFld                'drvl    drvrTmr2PnFld                mov     y, #0                       ' make single-pin variables.pin            altd    y, #pin_adc_u_i                mov     0-0, x                add     x, #1                incmod  y, #15      wc    if_nc       jmp     #.pin                dirl    all_pins                    ' disable PWM and ADC pins for configuration                wrpin   adc_modes+0, pin_adc_u_i        ' set up ADC pins                wrpin   adc_modes+0, pin_adc_v_i                wrpin   adc_modes+0, pin_adc_w_i                wrpin   adc_modes+0, pin_adc_cur_i                wxpin   #10, pin_adc_u_i                ' (#10 = 1024-clock / 11-bit conversion)                wxpin   #10, pin_adc_v_i                wxpin   #10, pin_adc_w_i                wxpin   #10, pin_adc_cur_i                wrpin   pwmn, pin_pwm_u_l               ' set up PWM pins                wrpin   pwmt, pin_pwm_u_h                wrpin   pwmn, pin_pwm_v_l                wrpin   pwmt, pin_pwm_v_h                wrpin   pwmn, pin_pwm_w_l                wrpin   pwmt, pin_pwm_w_h                wxpin   fram, pin_pwm_u_l                wxpin   fram, pin_pwm_u_h                wxpin   fram, pin_pwm_v_l                wxpin   fram, pin_pwm_v_h                wxpin   fram, pin_pwm_w_l                wxpin   fram, pin_pwm_w_h                dirh    all_pins                        ' enable ADC and PWM pins simultaneously for phase-locked operation                ' if we are to freewheel the motor let's float all drive pins                cmp     stop_mode_, #SM_FLOAT       wz  ' Q: should motor be freewheeling?    if_z        dirl    drive_pins                      ' YES: float all control pins (make them inputs)                dirl    pin_hall_u                      ' remake HALL pins inputs (they were in-between ADC and PWM pins)                dirl    pin_hall_v                dirl    pin_hall_w                mov     duty_, #0                       ' reset duty                mov     pos_, #0                        ' reset pos                mov     loop_dtcks_, #0                 ' just in case                mov     loop_ctcks_, #0                 ' just in case                mov     drv_incr, #0                    ' reset incr to stopped                mov     prior_incr, #0                  ' just in case                mov     fwdrev, #0                      ' just in case                ' do initial read of parms so control loop can use them                setq    #13-1                       ' load fresh parameter table (13 longs)                rdlong  params_ptr_+1, params_ptr_                ' preset our starting angle                'call    #.initAngleFmHall   ' NOTE: may not need this a SPIN_UP does this                ' reset timer (schedule next control time)                getct   ctrlEndTix                      ' get now                addct1  ctrlEndTix, cfg_ctcks_          '   add in next time we need to run                ' start driver                jmp     #.drvMotor    ' -------------------------------------------------------------------------.loop           jnct1   #.ctlMotor      ' if not time for control loop just go to drive loop    ' =========================================================================    '  MOTOR DRIVE LOOP - runs at 2.0 kHz (500.0 uSec period)    '       time to adjust angle...    ' -------------------------------------------------------------------------.drvMotor                getct   ctrlSrtTix                      ' remember when we started this loop                'outnot  drvrTmrPnFld                    ' toggle TEST marker pin                'outnot  drvrTmrPnFld                    ' toggle TEST marker pin                'outnot  drvrTmr2PnFld                   ' rising edge of duration meas.                or      e_stop_, e_stop_        wz      ' Q: Emergency Stop Requested?    if_z        jmp     #.noEStop                       ' No: continue on...eStop                dirl    drive_pins                      ' YES, at Emergency STOP: float all control pins (make them inputs)                mov     drv_state_, #DCS_ESTOP          ' report that we are stopped                jmp     #.endRqst.noEStop                cmp     drv_state_, #DCS_ESTOP  wz      ' Q: were we emergency stopped?    if_z        mov     drv_state_, #DCS_STOPPED        ' YES: reset to simply stopped so we start out pins correctly                rdlong  tgt_incr, ptra[-1]              ' get rate of increment ( +/- drive power, or 0 stop)                or      tgt_incr, tgt_incr      wz      ' Q: being asked to stop?    if_z        jmp     #.newCmd                        ' YES, allow 'stop' to proceed                ' Accept a new drive command only when not in middle of change                cmp     drv_state_, #DCS_STOPPED    wz      ' Q: STOPPED not doing anything?    if_nz       cmp     drv_state_, #DCS_AT_SPEED   wz      ' Q: AT_SPEED not doing anything?    if_nz       cmp     drv_state_, #DCS_FAULTED    wz      ' Q: FAULTED not doing anything?    if_nz       jmp     #.currRqst      ' no match, continue what we are doing                ' matched one, fall through to process new request...                ' let's see if user wants to change speed                ' have new drive command?.newCmd                rdlong  tgt_incr, ptra[-1]              ' get rate of increment ( +/- drive power, or 0 stop)                cmp     prior_incr, tgt_incr        wz  ' Q: do we have a new request?    if_z        jmp     #.currRqst      ' nope, just continue what we are doing    ' ====================================.newRqst    ' have new request            ' determine what we need to do    ' ====================================                ' if NEW request is stop                cmp     tgt_incr, stop_requst       wz  ' Q: is stop request?    if_z        mov     prior_incr, tgt_incr            ' have new request - set this a latest prior!    if_z        mov     drv_state_, #DCS_SPIN_DN        ' yes, so start ramp down    if_z        jmp     #.rampDn                ' have start or speed adjustment                cmp     drv_state_, #DCS_FAULTED    wz  ' Q: is MOTOR faulted?    if_nz       jmp     #.chkStopped                    ' NO, go to next check            ' MOTOR faulted, clear fault so we can run again                mov     tgt_incr, #0                    ' YES, reset incr to stopped                mov     drv_incr, #0                    ' reset incr to stopped                mov     prior_incr, #0                  ' along with prior                mov     fwdrev, #0                      ' just in case                mov     duty_, #0                       ' just in case                mov     drv_state_, #DCS_STOPPED        ' reset fault to stopped                call    #.initAngleFmHall               ' figure out where motor is once again                cmp     stop_mode_, #SM_FLOAT       wz  ' Q: are we floating pins during stop?    if_nz       dirh    drive_pins                      ' NO, set control pins back to output                ' fall thru to next handling code.chkStopped                cmp     drv_state_, #DCS_STOPPED    wz  ' Q: iare we stopped?    if_nz       jmp     #.notStart                      ' NO, go to next check                mov     prior_incr, tgt_incr            ' YES, have new request - set this a latest prior!                mov     drv_state_, #DCS_SPIN_UP        ' We are going to ramp up                ' if we have floated all drive pins, re-enable them                cmp     stop_mode_, #SM_FLOAT       wz  ' Q: did we float pins at last stop?    if_z        dirh    drive_pins                      ' yes, set control pins back to output                jmp     #.rampUp            ' now go ramp up!.notStart    ' ------------------------------------               ' no, We have a speed adjustment (determine how to do...)                '  NOTEs: [ + >> +, + >> -, - >> -, - >> +]                '    + to - -> make direction change (slow down, ramp up in other direction)                '    - to + -> make direction change (slow down, ramp up  in other direction)                '    + to larger + -> ramp up to new                '    + to smaller + -> ramp down to new                '    - to larger - -> ramp up to new                '    - to smaller - -> ramp down to new                ' first do we have same sign?                testb   prior_incr, #31             wc  ' find dual '-' signs (CY=both neg)                testb   tgt_incr, #31               andc    if_c        jmp     #.endSame                testbn  prior_incr, #31             wc  ' find dual '+' signs (CY=both pos)                testbn  tgt_incr, #31               andc.endSame    if_nc       jmp     #.notSame.haveSame   ' we have prior and new with same sign, so should we slow down or speed up?                ' let's change speed                testb   tgt_incr, #31               wc    if_c        jmp     #.doSloNeg.doSloPos                cmps    prior_incr, tgt_incr        wcz ' Q: Should we slow dn or speed up? (CY=speed up)                mov     prior_incr, tgt_incr            ' have new request - set this a latest prior!    if_c        mov     drv_state_, #DCS_SPIN_UP        ' CY=1: speed up    if_c        jmp     #.rampUp    if_nc       mov     drv_state_, #DCS_SLOWING_DN     ' CY=0: slow down    if_nc       jmp     #.slowDn.doSloNeg                cmps    prior_incr, tgt_incr        wcz ' Q: Should we slow dn or speed up? (CY=speed up)                mov     prior_incr, tgt_incr            ' have new request - set this a latest prior!    if_nc       mov     drv_state_, #DCS_SPIN_UP        ' CY=1: speed up    if_nc       jmp     #.rampUp    if_c        mov     drv_state_, #DCS_SLOWING_DN     ' CY=0: slow down    if_c        jmp     #.slowDn    ' ------------------------------------.notSame    ' we have prior and new but NOT the same sign, let's slowdown then change direction                ' let's change direction                mov     prior_incr, tgt_incr            ' have new request - set this a latest prior!                mov     drv_state_, #DCS_SLOW_TO_CHG                jmp     #.slow2Chg    ' ====================================.currRqst   ' No new request, continue with            '  current request    ' ====================================.chkStop        cmp     drv_state_, #DCS_STOPPED    wz    if_z        jmp     #.endRqst                       ' motor STOPPED, just exit (w/o increment)                ' motor is running, if ramp do ramp, else increment.chkUp          cmp     drv_state_, #DCS_SPIN_UP    wz    if_nz       jmp     #.chkDn                         ' not this, go check next.rampUp                ' if we don't have it, preset our starting angle (assume motor moved during float!)                cmp     stop_mode_, #SM_FLOAT       wz  ' if we are "floating" pins at stop    if_z        or      drv_incr, drv_incr          wz  ' -and- we are stopped, just about to spin up    if_z        call    #.initAngleFmHall               ' then, let's first get motor initial angle for smooth startup                ' do next UP adjustment or set at-speed                abs     abs_incr, drv_incr              ' get abs(drv_incr)                cmps    abs_incr, ramp_thresh       wc  ' Q: need early(slo) ramp?    if_nc       mov     curr_ramp, ramp_fast_           ' NO: use fast ramp rate    if_c        mov     curr_ramp, ramp_slo_            ' YES: use slow ramp rate                testb   tgt_incr, #31               wc  ' Q: moving FWD or REV? (CY=REV)    if_c        jmp     #.haveRUpRev                adds    drv_incr, curr_ramp             ' FWD: increase increment (speeding up)                cmps    tgt_incr, drv_incr          wc  ' Q: Did we exceed target?                jmp     #.lastRUpZero.haveRUpRev                subs    drv_incr, curr_ramp             ' REV: decrease increment (speeding up)                cmps    drv_incr, tgt_incr          wc  ' Q: Did we exceed target?.lastRUpZero    if_c        mov     drv_incr, tgt_incr              ' yes, reset to target!                cmps    tgt_incr, drv_incr          wz  ' Q: Are we at target? (compare again to handle both cases)    if_z        mov     drv_state_, #DCS_AT_SPEED       ' yes, show we got here!                jmp     #.justIncr      ' go increment motor angle, then exit    ' ------------------------------------.chkDn          cmp     drv_state_, #DCS_SPIN_DN    wz    if_nz       jmp     #.chkSlow2Chg.rampDn                ' do next DOWN adjustment or set stopped                '  (increment > 0, we are not stopped)                ' NOTE!!! tgt_incr is likely ZERO so we don't test its sign bit here                '  instead we test the sign bit of the current driver target as we are spinning down                '  from the current driver target to ZERO!                testb   drv_incr, #31               wc  ' Q: moving FWD or REV? (CY=REV)    if_c        jmp     #.haveRDnRev                subs    drv_incr, ramp_fast_              ' FWD: decrease increment (slowing down)                cmps    drv_incr, #0                wcz    if_nc_and_nz jmp    #.justIncr                       ' just increment motor angle, then exit                jmp     #.lastRDnzero.haveRDnRev                adds    drv_incr, ramp_fast_              ' REV: increase increment, toward zero (slowing down)                cmps    drv_incr, #0                wcz    if_c        jmp    #.justIncr                       ' just increment motor angle, then exit.lastRDnzero                subs    drv_incr, drv_incr              ' set to zero                mov     drv_state_, #DCS_STOPPED        ' report that we are stopped                mov     err_, #0                        ' reset err                mov     duty_, #0                       ' reset duty                ' if we are to freewheel the motor let's float all drive pins                cmp     stop_mode_, #SM_FLOAT       wz    if_z        dirl    drive_pins                      ' float all control pins (make them inputs)                jmp     #.endRqst       ' motor STOPPED, just exit (w/o increment)     ' ------------------------------------.chkSlow2Chg    cmp     drv_state_, #DCS_SLOW_TO_CHG wz    if_nz       jmp     #.chkSlowDn                     ' not this, go check next.slow2Chg                ' do next DOWN adjustment, if stopped do spinup                '  (increment > 0, we are not stopped)                ' NOTE!!! tgt_incr is where we are going after we spin down so we don't test its sign bit here                '  instead we test the sign bit of the current driver target as we are spinning down                '  from the current driver target to ZERO!                testb   drv_incr, #31               wc  ' Q: moving FWD or REV? (CY=REV)    if_c        jmp     #.haveS2CRev                subs    drv_incr, ramp_fast_              ' FWD: decrease increment (slowing down)                cmps    drv_incr, #0                wcz    if_nc_and_nz jmp    #.justIncr                      ' just increment motor angle, then exit                jmp     #.lastS2CZero.haveS2CRev                adds    drv_incr, ramp_fast_              ' REV: increase increment, toward zero (slowing down)                cmps    drv_incr, #0                wcz    if_c        jmp    #.justIncr                       ' just increment motor angle, then exit.lastS2CZero                subs    drv_incr, drv_incr              ' set to zero                sub     drv_incr, drv_incr              ' set to zero                mov     drv_state_, #DCS_SPIN_UP        ' report that we are stopped                jmp     #.rampUp        ' go immediately start moving in opposite direction    ' ------------------------------------.chkSlowDn      cmp     drv_state_, #DCS_SLOWING_DN wz    if_nz       jmp     #.justIncr          ' not this, guess we just increment motor angle, then exit.slowDn                ' do next DOWN adjustment or set at speed                '  (increment > 0, we are not stopped)                testb   tgt_incr, #31               wc  ' Q: moving FWD or REV? (CY=REV)    if_c        jmp     #.haveSDnRev                    ' REV, jump                subs    drv_incr, ramp_fast_            ' FWD: decrease increment (slowing down)                cmps    tgt_incr, drv_incr          wc  ' Q: Did we exceed target?                jmp     #.lastSDnZero.haveSDnRev                adds    drv_incr, ramp_fast_            ' REV: increase increment (slowing down)                cmps    drv_incr, tgt_incr          wc  ' Q: Did we exceed target?.lastSDnZero    if_nc       mov     drv_incr, tgt_incr              ' yes, reset to target!                cmps    tgt_incr, drv_incr          wz  ' Q: Are we at target? (compare again to handle both cases)    if_z        mov     drv_state_, #DCS_AT_SPEED       ' yes, show we got here!                'jmp     #.justIncr      ' go increment motor angle, then exit    ' ------------------------------------.justIncr   ' just do our increment of angle and we're done!                add     angle, drv_incr                'jmp    #.endRqst      ' done, fall thru.endRqst                getct   loop_ctcks_                 ' how long was this pass? send to host                sub     loop_ctcks_, ctrlSrtTix                ' reset timer (schedule next control loop run)                mov     ctrlEndTix, ctrlSrtTix                addct1  ctrlEndTix, cfg_ctcks_                'outnot  drvrTmr2PnFld                   ' falling edge of duration meas.               'jmp    #.ctlMotor      ' done, fall thru    ' -------------------------------------------------------------------------.ctlMotor    ' =========================================================================    '  MOTOR Speed Maintenance Loop - runs at 43.9 kHz (22.8 uSec period)    '       keep our error rate low...    ' -------------------------------------------------------------------------                getct   drvrSrtTix                  ' remember when we started this loop                'outnot  drvrLoopPnFld               ' toggle TEST marker pin                'outnot  drvrLoopPnFld                call    #.wait4adc                  ' allow ADC rest period (Period 1 of 6)                rdpin   vio_levels+0, pin_adc_u_i       ' VIO samples done, read them                rdpin   vio_levels+1, pin_adc_v_i                rdpin   vio_levels+2, pin_adc_w_i                rdpin   vio_levels+3, pin_adc_cur_i                wrpin   adc_modes+2, pin_adc_u_i        ' switch ADC to pin                wrpin   adc_modes+2, pin_adc_v_i                wrpin   adc_modes+2, pin_adc_w_i                wrpin   adc_modes+2, pin_adc_cur_i                call    #.wait4adc                  ' allow ADC rest period (Period 2 of 6)                call    #.wait4adc                  ' allow ADC rest period (Period 3 of 6)                rdpin   sense_u_, pin_adc_u_i           ' pin samples done, read them                rdpin   sense_v_, pin_adc_v_i                rdpin   sense_w_, pin_adc_w_i                rdpin   sense_i_, pin_adc_cur_i                wrpin   adc_modes+0, pin_adc_u_i        ' switch ADC to GIO calibration                wrpin   adc_modes+0, pin_adc_v_i                wrpin   adc_modes+0, pin_adc_w_i                wrpin   adc_modes+0, pin_adc_cur_i                call    #.wait4adc                  ' allow ADC rest period (Period 4 of 6)                sub     vio_levels+0, gio_levels+0  ' compute (3300 << 11) / (vio_level - gio_level)                sub     vio_levels+1, gio_levels+1                sub     vio_levels+2, gio_levels+2                sub     vio_levels+3, gio_levels+3                qdiv    numerator, vio_levels+0                qdiv    numerator, vio_levels+1                qdiv    numerator, vio_levels+2                qdiv    numerator, vio_levels+3                getqx   scl_levels+0                waitx   #4                getqx   scl_levels+1                waitx   #4                getqx   scl_levels+2                waitx   #4                getqx   scl_levels+3                sub     sense_u_, gio_levels+0      ' compute (quotient * (pin_level - gio_level)) >> 11                muls    sense_u_, scl_levels+0                sar     sense_u_, #11                sub     sense_v_, gio_levels+1                muls    sense_v_, scl_levels+1                sar     sense_v_, #11                sub     sense_w_, gio_levels+2                muls    sense_w_, scl_levels+2                sar     sense_w_, #11                sub     sense_i_, gio_levels+3                muls    sense_i_, scl_levels+3                sar     sense_i_, #11                call    #.wait4adc                  ' allow ADC rest period (Period 5 of 6)                rdpin   gio_levels+0, pin_adc_u_i       ' GIO samples done, read them                rdpin   gio_levels+1, pin_adc_v_i                rdpin   gio_levels+2, pin_adc_w_i                rdpin   gio_levels+3, pin_adc_cur_i                wrpin   adc_modes+1, pin_adc_u_i        ' switch ADC to VIO calibration                wrpin   adc_modes+1, pin_adc_v_i                wrpin   adc_modes+1, pin_adc_w_i                wrpin   adc_modes+1, pin_adc_cur_i                call    #.wait4adc                  ' allow ADC rest period (Period 6 of 6)                mov     y, duty_                    ' feed three CORDIC operations to get phase drive levels                shr     y, #4                mov     x, angle                qrotate y, x                add     x, third                qrotate y, x                add     x, third                qrotate y, x                getqy   drive_u_                    ' get three CORDIC results                getqy   drive_v_                getqy   drive_w_                mov     x, drive_u_                 ' get smallest drive level into x                cmps    x, drive_v_         wc    if_nc       mov     x, drive_v_                cmps    x, drive_w_         wc    if_nc       mov     x, drive_w_                mov     y, drive_u_                 ' get largest drive level into y                cmps    y, drive_v_         wc    if_c        mov     y, drive_v_                cmps    y, drive_w_         wc    if_c        mov     y, drive_w_                add     x, y                        ' sum smallest and largest, then divide by 2                sar     x, #1                sub     drive_u_, x                 ' subtract difference from drive levels                sub     drive_v_, x                sub     drive_w_, x                add     drive_u_, bias              ' add center-bias and dead-time offsets to update PWMs                add     drive_u_, dead_gap_                wypin   drive_u_, pin_pwm_u_l                sub     drive_u_, dead_gap_                wypin   drive_u_, pin_pwm_u_h                add     drive_v_, bias                add     drive_v_, dead_gap_                wypin   drive_v_, pin_pwm_v_l                sub     drive_v_, dead_gap_                wypin   drive_v_, pin_pwm_v_h                add     drive_w_, bias                add     drive_w_, dead_gap_                wypin   drive_w_, pin_pwm_w_l                sub     drive_w_, dead_gap_                wypin   drive_w_, pin_pwm_w_h                testp   pin_hall_w              wc      ' read hall effect sensor                rcl     hall_, #1                testp   pin_hall_v              wc                rcl     hall_, #1                testp   pin_hall_u              wc                rcl     hall_, #1                and     hall_, #%111_111            ' (old << 3 | new) [ooo:nnn]                altgb   hall_, #deltas              ' load byte deltas[hall_] -> [-1, 0, 1]                getbyte x                signx   x, #7                       ' sign-extend bit7                add     pos_, x                     ' add to current pos_                setq    #13-1                       ' load fresh parameter table (13 longs)                rdlong  params_ptr_+1, params_ptr_                cmpm    angle, prior_angle  wcz     ' if angle has changed, forward or reverse?    if_nz       wrc     fwdrev                mov     prior_angle, angle                testb   fwdrev, #0          wc      ' determine error                bitc    hall_, #3                and     hall_, #%1111                alts    hall_, #hall_angles                mov     err_, 0-0    if_c        add     err_, offset_fwd_    if_nc       add     err_, offset_rev_                subr    err_, angle                sar     err_, #24                bitl    hall_, #3                abs     x, err_                     ' fault?                cmp     x, #125             wc    if_nc       dirl    drive_pins                  ' at FAULT: float all control pins (make them inputs)    if_nc       mov     drv_state_,#DCS_FAULTED     '  also on FAULT: mark our motor as FAULTED    if_nc       wrlong  #1, ptra[14]                '  also on FAULT: report fault                sub     x, #256/6           wc      ' modulate duty    if_nc       muls    x, duty_up_    if_c        muls    x, duty_dn_                sar     x, #8                add     duty_, x                fles    duty_, duty_max_            ' keep duty within limits                fges    duty_, duty_min_                getct   loop_dtcks_                 ' how long was this iteration? send to host                sub     loop_dtcks_, drvrSrtTix                setq    #14-1                       ' write drive[3]/sense[4]/hall/pos/duty/err/ticks[2]/state to hub                wrlong  drive_u_, ptra                jmp     #.loop                      ' main loop    ' =========================================================================    '  PRIVATE (Utiility) Subroutines    ' -------------------------------------------------------------------------.wait4adc       testp   pin_adc_u_i             wc      ' wait for next ADC sample (6 samples = PWM frame)    if_nc       jmp     #.wait4adc    _ret_       akpin   pin_adc_u_i.initAngleFmHall                ' init angle & prior from current motor position                testp   pin_hall_w              wc      ' read hall effect sensor                rcl     hall_, #1                testp   pin_hall_v              wc                rcl     hall_, #1                testp   pin_hall_u              wc                rcl     hall_, #1'                and     hall_, #%111               ' assume forward                testb   tgt_incr, #31           wc  ' Q: moving FWD or REV? (CY=REV)    if_c        or      hall_ , #%1000              ' REV point to REV half of table    if_nc       and     hall_, #%111                ' FWD point to FWD half of table                alts    hall_, #hall_angles                mov     angle, 0-0                add     angle, offset_fwd_          ' adjust phase offset for hall sensor    _ret_       mov     prior_angle, angle          ' show we are already here    '    ' =========================================================================all_pins        LONG    15 << 6                             ' all-pins variable (addpins 15) needs OR of basepindrive_pins      LONG    (7 << 6) + 8                ' drive-pins variable (+8 addpins 7) needs ADD of basepinpwmt        LONG    %000_000000_01_01000_0  ' PWM truepwmn        LONG    %001_000000_01_01000_0  ' PWM notfram        LONG    FRAME << 16 + 1         ' PWM frame settingbias        LONG    FRAME / 2               ' PWM center-frame biasthird       LONG    1 FRAC 3                ' 120 degreesnumerator   LONG    3300 << 11              ' numerator for ADC calculationsstop_requst LONG    0                       ' 32-bits of zeroramp_thresh LONG    25_000_000              ' fm zero - slow ramp to here then fast ramp ( ~1/5 of 0-max )'drvrLoopPnFld   LONG    TEST_PIN_DRIVER_LOOP addpins 0  ' convert to pinfield'drvrTmrPnFld    LONG    TEST_PIN_DRIVER_TMR addpins 0  ' convert to pinfield'drvrTmr2PnFld   LONG    TEST_PIN_DRIVER_TMR2 addpins 0  ' convert to pinfieldadc_modes   LONG    p_adc_gio | p_adc       ' adc modes, by state            LONG    p_adc_vio | p_adc            LONG    p_adc_1x  | p_adcdeltas      BYTE    0, 0, 0, 0, 0, 0, 0, 0  ' Hall-effect-sensor position deltas from (old<<3 | new)            BYTE    0, 0, 0,-1, 0, 1, 0, 0            BYTE    0, 0, 0, 1, 0, 0,-1, 0            BYTE    0, 1,-1, 0, 0, 0, 0, 0            BYTE    0, 0, 0, 0, 0,-1, 1, 0            BYTE    0,-1, 0, 0, 1, 0, 0, 0            BYTE    0, 0, 1, 0,-1, 0, 0, 0            BYTE    0, 0, 0, 0, 0, 0, 0, 0hall_angles LONG    0           ' forward-direction table            LONG    0 frac 6    '%001            LONG    4 frac 6    '%010            LONG    5 frac 6    '%011            LONG    2 frac 6    '%100            LONG    1 frac 6    '%101            LONG    3 frac 6    '%110            LONG    0            LONG    0           ' reverse-direction table            LONG    5 frac 6    '%001            LONG    3 frac 6    '%010            LONG    4 frac 6    '%011            LONG    1 frac 6    '%100            LONG    0 frac 6    '%101            LONG    2 frac 6    '%110            LONG    0x               res 1           ' miscellaneousy               res 1' measurementsdrvrSrtTix      res 1drvrEndTix      res 1ctrlSrtTix      res 1ctrlEndTix      res 1' driver inputstgt_incr        res 1       ' current user requested target incrementprior_incr      res 1       ' prior user requested target increment' control loop variablesdrv_incr        res 1       ' current driver incrementangle           res 1       ' current driver angleprior_angle     res 1       ' prior driver anglefwdrev          res 1       ' driver current direction used for indexing into hall angle tablecurr_ramp       res 1abs_incr        res 1' PIN namespin_adc_u_i     res 1       ' single-pin variablespin_adc_v_i     res 1pin_adc_w_i     res 1pin_adc_x_i     res 1pin_adc_cur_i   res 1pin_hall_u      res 1pin_hall_v      res 1pin_hall_w      res 1pin_pwm_u_l     res 1pin_pwm_u_h     res 1pin_pwm_v_l     res 1pin_pwm_v_h     res 1pin_pwm_w_l     res 1pin_pwm_w_h     res 1pin_pwm_x_l     res 1pin_pwm_x_h     res 1'  ADC variablesgio_levels      res 4vio_levels      res 4scl_levels      res 4' ------------------------------'  PRECISE FORMAT:'   copied in-to driver each loop iterationparams_ptr_ res 1               ' params_ptr must be followed by the 13 parametersoffset_fwd_ res 1offset_rev_ res 1duty_min_   res 1duty_max_   res 1duty_up_    res 1duty_dn_    res 1dead_gap_   res 1               ' this was OFFSET but now passed into driverpwm_limit_  res 1               ' this was PWMLIM but now passed into drivercfg_ctcks_  res 1stop_mode_  res 1e_stop_     res 1               ' T/F where T means stopal motor functionramp_fast_  res 1               ' angle increment: add this every 500 uSec to ramp up to speedramp_slo_   res 1               ' angle decrement: subtract this every 500 uSec to ramp down to slower speed' ------------------------------'  PRECISE FORMAT:'   copied out-of driver each loop iterationdrive_u_    res 1               '   14 contiguous longs for return data structuredrive_v_    res 1drive_w_    res 1sense_u_    res 1sense_v_    res 1sense_w_    res 1sense_i_    res 1hall_       res 1pos_        res 1duty_       res 1err_        res 1loop_dtcks_ res 1loop_ctcks_ res 1drv_state_  res 1       ' enum: DCS_STOPPED, DCS_SPIN_UP, DCS_AT_SPEED, DCS_SPIN_DN, etc' fault is here... (but external only)    fit     496CON { license }{{ -------------------------------------------------------------------------------------------------  MIT License  Copyright (c) 2022 Iron Sheep Productions, LLC  Permission is hereby granted, free of charge, to any person obtaining a copy  of this software and associated documentation files (the "Software"), to deal  in the Software without restriction, including without limitation the rights  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell  copies of the Software, and to permit persons to whom the Software is  furnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all  copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  SOFTWARE. =================================================================================================}}